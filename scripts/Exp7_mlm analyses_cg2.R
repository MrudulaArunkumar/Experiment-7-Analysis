#workspace aufraeumen####
rm(list=ls())

#notwendige Pakete laden####
library(plyr)
library(lme4)
library(tidyverse)

#set working directory
setwd("~/Daten/1 BRAC-FOR/overshadowing/Exp 7/Analysis")

# 
# Exp7data <- read.csv(file="Data/Exp7_fulldataset.csv")
# 
# Exp7data$participant <- as.factor(Exp7data$participant)
# 
# 
# 
# # Data preparation and cleaning
# 
# # -   Removing unnecessary columns generated by psychopy
# # -   Preparing the RT trial, by eliminating the square brackets and splitting it in cases where two keys were registered.
# # -   Creating a column for Accuracy and Error Rate
# # -   adding a Bonus column that computes the points received by each participant
# 
# Exp7data <- Exp7data %>%
#   select(-X,-ConsentKey.keys,-ConsentKey.rt,-Begin.keys,-Begin.rt,-checkresp.corr,-checkresp.keys,-checkresp.rt,-Attention.thisRepN,-Attention.thisTrialN,-Attention.thisN,-Attention.thisIndex,-Attention.ran,-AttnQuestion,-AttnAnswer,-NextStep.keys,-NextStep.rt,-InstRep.ran,-InstRep.thisN,-InstRep.thisTrialN,-InstRep.thisRepN,-InstRep.thisIndex,-PracProceed.keys,-PracProceed.rt,-Prac_loop.thisRepN,-Prac_loop.thisTrialN,-Prac_loop.thisN,-Prac_loop.thisIndex,-Prac_loop.ran,-Exp_proceed.keys,-Exp_proceed.rt,-PracRepeat.ran,-PracRepeat.thisRepN,-PracRepeat.thisN,-PracRepeat.thisIndex,-PracRepeat.thisTrialN,-brkContinue.keys,-PauseResp.keys,-PauseResp.rt,-CALearntrials.thisRepN,-CALearntrials.ran,-CALearntrials.thisTrialN,-CALearntrials.thisIndex, -CA_Proceed.keys,-CA_Proceed.rt,-headstartLearn.thisRepN,-headstartLearn.thisTrialN,-headstartLearn.thisIndex,-headstartLearn.thisN,-headstartLearn.ran,-ExpTrials.ran,-ExpTrials.thisIndex,-CA_trials.thisRepN,-CA_trials.thisN,-CA_trials.thisIndex,-CA_trials.thisTrialN,-CA_trials.ran,-AwareQ_loop.thisRepN,-AwareQ_loop.ran,-AwareQ_loop.thisIndex,-AwareQ_loop.thisTrialN,-todebrief.keys,-Finalend.keys)
# 
# 
# 
# #adjusting RT
# Exp7data$mainRT <- Exp7data$TargetResp.rt
# Exp7data$Block1RT <- Exp7data$CAResponse.rt
# 
# #splitting the RTs from main block
# Exp7data <- separate(Exp7data, col = mainRT, into = c("RTm_Trials", "RTm_secondary"), sep = ',')
# Exp7data$RTm_Trials <- Exp7data$RTm_Trials%>%
#   str_replace_all("\\[|\\]","")%>%
#   as.double(Exp7data$RTm_Trials)
# Exp7data$RTm_Trials <- 1000*(Exp7data$RTm_Trials)
# 
# #splitting RTs from the Ca learn block (1st block)
# Exp7data <- separate(Exp7data, col = Block1RT, into = c("RTb_Trials", "RTb_secondary"), sep = ',')
# Exp7data$RTb_Trials <- Exp7data$RTb_Trials%>%
#   str_replace_all("\\[|\\]","")%>%
#   as.double(Exp7data$RTb_Trials)
# Exp7data$RTb_Trials <- 1000*(Exp7data$RTb_Trials)
# 
# #removing RTs from guessing trials 
# Exp7data$RTb_Trials <- ifelse(Exp7data$Block == "CG Learn", NA, Exp7data$RTb_Trials)
# 
# #creating a dummy variable to pick wherever the RTs are from main block and which are from first block
# Exp7data$RTdummy <- ifelse(is.na(Exp7data$TargetResp.rt) == FALSE,1,NA)
# Exp7data$RTdummy <- ifelse(is.na(Exp7data$CAResponse.rt)==FALSE,2,Exp7data$RTdummy)
# 
# #combining all important RTs 
# Exp7data <- Exp7data %>%
#   mutate(RT_Trials = ifelse((RTdummy == 1), RTm_Trials,ifelse((RTdummy == 2),RTb_Trials,NA)))
# 
# 
# ###creating a separate df with the contingency awareness
# Exp7_CA <- Exp7data%>%
#   filter(Target == "?" | str_detect(AwareQ, "Press"))
# 
# 
# 
# 
# 
# Exp7data <- Exp7data%>%drop_na(RT_Trials)
# 
# #combining accuracy from first block and main block
# Exp7data$mainAcc <- Exp7data$TargetResp.corr
# Exp7data$Block1Acc <- Exp7data$CAResponse.corr
# Exp7data$BlockAcc <- ifelse(Exp7data$Block == "CG Learn", NA, Exp7data$Block1Acc)
# 
# Exp7data$ACCdummy <- ifelse(is.na(Exp7data$TargetResp.corr)==FALSE,1,NA)
# Exp7data$ACCdummy <- ifelse(is.na(Exp7data$CAResponse.corr)==FALSE,2,Exp7data$ACCdummy)
# 
# Exp7data <- Exp7data %>%
#   mutate(ACC_trials = ifelse((ACCdummy == 1),mainAcc,ifelse((ACCdummy == 2),Block1Acc,NA)))
# 
# 
# Exp7data$ErrorRate <- 1 - Exp7data$ACC_trials
# 
# #Error rate
# table(Exp7data$ACC_trials)
# round(table(Exp7data$ACC_trials)/nrow(Exp7data)*100, digits = 3)
# 
# #Exclude errors from RT
# 
# Exp7data$RT_Trials[Exp7data$ACC_trials==0] <- NA
# summary(Exp7data$RT_Trials)
# 
# #exclude outliers
# #creating function to remove the outliers and farouts
# computeTukeys <- function(x){
#   P25 <- quantile(x$RT_Trials, .25, na.rm = TRUE, type = 6) #type = 6 -> used in SPSS
#   P75 <- quantile(x$RT_Trials, .75, na.rm = TRUE, type = 6)
#   x$Outlier <- P75 + 1.5*(P75 - P25)
#   x$Farouts <- P75 + 3.0*(P75 - P25)
#   return(x)
# }
# 
# 
# #identifying the outliers and farouts at individual level
# Exp7data <- ddply(Exp7data, .(participant), computeTukeys)
# 
# #creating new column with RT trials after removing outliers/farouts
# Exp7data$RT_io <- Exp7data$RT_Trials
# 
# Exp7data$RT_io[Exp7data$RT_io > Exp7data$Outlier|Exp7data$RT_io < 200] <- NA
# summary(Exp7data$RT_io)
# 
# 
# 
# raw.data<-Exp7data
# 
# #exclude participant with too many errors
# raw.data<-subset(raw.data, subset=(raw.data$participant!="10"))
# 
# 
# raw.data<-raw.data%>%
#   select(Validity, Saliency, Condition, SalD, NSalD, CorrectAnswer, Target, RT_Trials, ACC_trials, participant, RT_io)
# 
# #compute new vars####
#   #compute new numeric var for validity effect
#   raw.data$val <-ifelse(raw.data$Validity=="valid",1,-1)
#   table(raw.data$val, raw.data$Validity)
#   
#   table(raw.data$val, raw.data$Condition)
# 
#   #numeric var for saliency
#   raw.data$sal<-ifelse(raw.data$Saliency=="Salient",1,
#                        ifelse(raw.data$Saliency=="NonSalient", -1, NA))
# 
#   table(raw.data$Saliency, raw.data$sal)
#   
#   
#   #new var for distance of last occurrence of identical D stimulus####
#   
#   ###first is to find out the trials where the previous occurence wa the immediate previous one
#   raw.data$Distance <- NA
#   raw.data <- raw.data%>%select(Distance,ACC_trials,everything())
#   raw.data <- raw.data%>%
#     mutate(Distance = ifelse((lag(Condition,1)=="test" | lag(Condition,1) == "learn")& 
#                                (lag(SalD,1)== SalD|lag(NSalD,1)==NSalD) &
#                                lag(participant,1)==participant &
#                                lag(ACC_trials,1)== 1, 1, Distance))
#   
#   
#   #The number of immediate previous occurences
#   
#   table(raw.data$Distance)
#   
#   ## Now to look at other distances of the last occurrence beyond the immediately preceding one
#   lagvalue <- 2:20
#   
#   for(j in lagvalue){
#     raw.data <- raw.data %>% 
#       mutate(Distance = ifelse((lag(Condition,j)=="learn"|lag(Condition,j)=="test") &  
#                                  (lag(SalD,j)==SalD|lag(NSalD,j)==NSalD) & lag(participant,j)==participant &
#                                  lag(ACC_trials,j)== 1 & is.na(Distance)==TRUE, j, Distance))
#   }
#   
#   table(raw.data$Distance)
#   
#   #code trial type for previous distance: learn trial = 1, test trial=2
#   raw.data$Distance_type<-NA
#   raw.data <- raw.data%>%
#     mutate(Distance_type = ifelse(Distance==1 & lag(Condition,1)=="learn",1,
#                                   ifelse(Distance==1 &lag(Condition,1)=="test", 2, Distance_type)))
#   
#   table(raw.data$Distance_type)
#   raw.data <- raw.data%>%
#     select(Distance, Distance_type, Condition, everything())
#   
#   #code for nonimmediate distances
#   for (j in lagvalue){
#     raw.data <- raw.data%>%
#       mutate(Distance_type = ifelse(Distance==j & lag(Condition,j)=="learn", 1,
#                                     ifelse(Distance==j &lag(Condition,j)=="test", 2, Distance_type)))
#     }
#   
#   ### Previous Response
#   
#   # Coding what the previous Response was, whether it was the same or different. This variable is defined as Response Type, which has two factors: Response Change(RC) and Response Repetition (RR)
#   
#   raw.data$ResponseType <- NA
#     Rmlag <- 1:30
#   for(k in Rmlag){
#     raw.data <- raw.data %>% 
#       mutate(ResponseType = ifelse((lag(Condition,k)=="learn" | lag(Condition,k)=="test") &  
#                                      (lag(SalD,k)==SalD|lag(NSalD,k)==NSalD) & lag(participant,k)==participant & 
#                                      lag(CorrectAnswer,k)== CorrectAnswer & is.na(ResponseType)==TRUE, "RR", 
#                                    ifelse((lag(Condition,k)=="learn"|lag(Condition,k)=="test") & (lag(SalD,k)==SalD|lag(NSalD,k)==NSalD)& lag(participant,k)==participant & lag(CorrectAnswer,k)!= CorrectAnswer & is.na(ResponseType)==TRUE, "RC", ResponseType)))
#   }
#   
#   table(raw.data$ResponseType)
#   
#   raw.data <- raw.data%>%select(ResponseType,RT_io,CorrectAnswer, everything())
#   
#   
# 
#    write.csv2(raw.data, file="Data/DataForMLM.csv", row.names = F)
  
  #+++++++++++++++++++++++++++++++++++####
  #MULTILEVEL ANALYSIS####
  #+++++++++++++++++++++++++++++++++++++++
  
   
raw.data<-read.csv2(file="Data/DataForMLM.csv")
   

#create numerical var for response type

raw.data$previous_rm<-ifelse(raw.data$ResponseType=="RR", 1, 2)
table(raw.data$ResponseType, raw.data$previous_rm)


#limit analyses to testtrials only ####
table(raw.data$Condition)
raw.data<-subset(raw.data, subset = (raw.data$Condition=="test"))

#limit analyses to test trials whose last occurrence was a learning trial
raw.data<-subset(raw.data, subset = (raw.data$Distance_type==1))


#center predictors####
#factors validity and saliency contrast coded with -1/1 as levels
summary(raw.data$val)
summary(raw.data$sal)


#centering within person (recommended, since hypotheses focus on level 1 predictors####

summary(raw.data$previous_rm)
summary(raw.data$Distance)
summary(raw.data$Distance_type)
  
  #previous_rm
  means.previous_rm <- aggregate(data = raw.data, previous_rm ~ participant, mean)
  names(means.previous_rm)[2]<-"previous_rm_mean"
  
  raw.data<-merge (raw.data, means.previous_rm, by="participant")
  
  raw.data$previous_rm_cwp <- raw.data$previous_rm-raw.data$previous_rm_mean
  summary(raw.data$previous_rm_cwp)
  
  #check whether person mean centering was correctly done
  all(raw.data$previous_rm == raw.data$previous_rm_cwp+raw.data$previous_rm_mean)


  #Distance
  means.Distance<- aggregate(data = raw.data, Distance ~ participant, mean)
  names(means.Distance)[2]<-"Distance_mean"
  
  raw.data<-merge (raw.data, means.Distance, by="participant")
  
  raw.data$Distance_cwp <- raw.data$Distance-raw.data$Distance_mean
  summary(raw.data$Distance_cwp)
  
  #check whether person mean centering was correctly done
  all(raw.data$Distance == raw.data$Distance_cwp+raw.data$Distance_mean)
  

  #Distance type
  
  # means.Distance_type<- aggregate(data = raw.data, Distance_type ~ participant, mean)
  # names(means.Distance_type)[2]<-"Distance_type_mean"
  # 
  # raw.data<-merge (raw.data, means.Distance_type, by="participant")
  
  # raw.data$Distance_type_cwp <- raw.data$Distance_type-raw.data$Distance_type_mean
  # summary(raw.data$Distance_type_cwp)
  # 
  #check whether person mean centering was correctly done
  # all(raw.data$Distance_type == raw.data$Distance_type_cwp+raw.data$Distance_type_mean)
  
#new var for errors
  raw.data$err_trials <-1-raw.data$ACC_trials
  


#MLM Analyses ####
#Start with MLM Model (random slopes) that corresponds to ANOVA on aggregated data
  #FActors: Validity (1=valid, -1=invalid) and Saliency (1=salient D, -1=nonsalient D), only test trials enter into analyses
  #validity effect: RT are faster for valid compared to invalid trials
  #saliency effct: RT are faster for salient compared to nonsalient D
  #interaction:
  
 
  #RT
randomSlopes_m1<-lmer(RT_io~1+val*sal + (1+val*sal|participant), 
                      data=raw.data, 
                      REML=F,
                      na.action = "na.omit")

summary(randomSlopes_m1)

#Check Richtung der Interaktion (kann man sich "simple slopes" auch für MLM anzeigen lassen?) -  validity effect should occur only for salient D, not for nonsalient D -> works
# salientD<-subset(raw.data, subset = (raw.data$sal==1))
# randomSlopes_m11<-lmer(RT_io~1+val + (1+val|participant),
#                       data=salientD,
#                       REML=F,
#                       na.action = "na.omit")
# 
# summary(randomSlopes_m11)
# # 
# nonsalientD<-subset(raw.data, subset = (raw.data$sal==-1))
# randomSlopes_m12<-lmer(RT_io~1+val + (1+val|participant),
#                        data=nonsalientD,
#                        REML=F,
#                        na.action = "na.omit")
# 
# summary(randomSlopes_m12)
# 
#Error rates

randomSlopes_m1_err<-lmer(err_trials~1+val*sal + (1+val*sal|participant), 
                      data=raw.data, 
                      REML=F,
                      na.action = "na.omit")

summary(randomSlopes_m1_err)

#Check pattern behind IA
# randomSlopes_m11_err<-lmer(err_trials~1+val + (1+val|participant),
#                       data=salientD,
#                       REML=F,
#                       na.action = "na.omit")
# 
# summary(randomSlopes_m11_err)
# 
# 
# randomSlopes_m12_err<-lmer(err_trials~1+val + (1+val|participant),
#                        data=nonsalientD,
#                        REML=F,
#                        na.action = "na.omit")
# 
# summary(randomSlopes_m12_err)
# 
# 
# #Will Interaction survive once we control for binding & retrieval effects?
# #previous_response match, distance, as main effects
# randomSlopes_m2<-lmer(RT_io~1+val*sal + previous_rm_cwp+ Distance_cwp  +(1+val*sal + previous_rm_cwp + Distance_cwp + Distance_type_cwp|participant), 
#                       data=raw.data, 
#                       REML=F,
#                       na.action = "na.omit")
# 
# summary(randomSlopes_m2)
# 
# 
# randomSlopes_m2_err<-lmer(err_trials~1+val*sal + previous_rm_cwp+ Distance_cwp + Distance_type_cwp +(1+val*sal + previous_rm_cwp + Distance_cwp + Distance_type_cwp|participant), 
#                       data=raw.data, 
#                       REML=F,
#                       na.action = "na.omit")
# 
# summary(randomSlopes_m2_err)

#Model ohne Val and Sal, dafür mit Interaktionen von Distance, previous_rm, und Distance type
randomSlopes_m3<-lmer(RT_io~1+ previous_rm_cwp*Distance_cwp +(1 + previous_rm_cwp*Distance_cwp|participant), 
                      data=raw.data, 
                      REML=F,
                      na.action = "na.omit")

summary(randomSlopes_m3)


randomSlopes_m3_err<-lmer(err_trials~1+ previous_rm_cwp*Distance_cwp +(1 + previous_rm_cwp*Distance_cwp|participant), 
                      data=raw.data, 
                      REML=F,
                      na.action = "na.omit")

summary(randomSlopes_m3_err)

#RT:Einfaches SR binding hat "besten" effekt, aber nsign (t=1.73)
#Err: previous_rm x distance ia sign

#Interaktion Val*Sal wieder mit aufnehmen
randomSlopes_m4<-lmer(RT_io~1+val*sal+previous_rm_cwp*Distance_cwp +(1+val*sal+previous_rm_cwp*Distance_cwp|participant), 
                      data=raw.data, 
                      REML=F,
                      na.action = "na.omit")

summary(randomSlopes_m4)
#Modell with 4way interaction does not converge

randomSlopes_m4_err<-lmer(err_trials~1+val*sal + previous_rm_cwp*Distance_cwp +(1+val*sal + previous_rm_cwp*Distance_cwp|participant), 
                      data=raw.data, 
                      REML=F,
                      na.action = "na.omit")

summary(randomSlopes_m4_err)
#RT: val *sal Interaction still significant
#Err: val *sal Interaction still significant, in addition, previous_rm*distance sign

randomIntercept_m0<-lmer(RT_io~1 + (1|participant), 
                         data=raw.data, 
                         REML=F,
                         na.action = "na.omit")
summary(randomIntercept_m0)

randomIntercept_m0_err<-lmer(err_trials~1 + (1|participant), 
                         data=raw.data, 
                         REML=F,
                         na.action = "na.omit")
summary(randomIntercept_m0_err)

#Model comparison
#Model 3 vs Model0

anova(randomIntercept_m0, randomSlopes_m1)
anova(randomIntercept_m0_err, randomSlopes_m1_err)
#model 1 has sign better fit than model 0 for RT and Err

anova(randomSlopes_m1, randomSlopes_m2)
anova(randomSlopes_m1_err, randomSlopes_m2_err)
#model 2 has no  better fit than model 0 for RT and Err

anova(randomSlopes_m1, randomSlopes_m4)

#++++++++++++++++++++++++++++++++++++++++
#further ideas, meeting march, 31st 2021

#only analyse salient test trials (to reduce number of predictors)
raw.data<-subset(raw.data, subset = (raw.data$Saliency=="Salient"))


#RT
randomSlopes_m5<-lmer(RT_io~1+val + (1+val|participant), 
                      data=raw.data, 
                      REML=F,
                      na.action = "na.omit")

summary(randomSlopes_m5)
#val effect sign

#ERR
randomSlopes_m5_err<-lmer(err_trials~1+val + (1+val|participant), 
                      data=raw.data, 
                      REML=F,
                      na.action = "na.omit")

summary(randomSlopes_m5_err)
#val effect sign

#model 6: include binding factors (previous_rm and distance, check whether val effect survives)
randomSlopes_m6<-lmer(RT_io~1+val*previous_rm_cwp*Distance_cwp + (1+val*previous_rm_cwp*Distance_cwp|participant), 
                      data=raw.data, 
                      REML=F,
                      na.action = "na.omit")

summary(randomSlopes_m6)
#val main effect no longer sign (t=1.273), but: distance and previous_rm ns, either (and no interaction)

#err

randomSlopes_m6_err<-lmer(err_trials~1+val*previous_rm_cwp*Distance_cwp + (1+val*previous_rm_cwp*Distance_cwp|participant), 
                      data=raw.data, 
                      REML=F,
                      na.action = "na.omit")

summary(randomSlopes_m6_err)
#err rates: val main effect still sign (t=-2.599), previous_rm, distance, previous_rm*distance: ns
